@begin[ref=index](section)
   @title(Overview)
   @c(cl-libheif) is a wrapper around libheif library which is a library for
   manipulation with HEIF format. Currently, this wrapper has support for
   encoding and decoding of toplevel images and extraction of metadata. Also,
   currently only images with 8 bits per color are supported.

   Dependencies:
   @begin(list)
     @item(libheif >= 1.17.6 (with headers!))
     @item(libffi)
     @item(C compiler, due to limitations in CFFI)
   @end(list)
@end(section)

@begin(section)
   @title(Naming convention)
   CL-libheif generally repeats the names of functions in libheif with the
   following modifications:
   @begin(list)
     @item(@c(heif-) prefix is removed.)
     @item(The word @c(get) is omitted.)
     @item(When a function has any user-observable side effects, e.g. it changes
     some internal state, creates files in a file system etc., it ends with an
     exclamation point (@c(!)).)
     @item(If a function is a predicate, @c(-p) suffix is added to the name.)
   @end(list)
   Also cl-libheif does not export any functions which create resources which
   must be explicitly freed later. Instead it exports @c(with-) macros with the
   same functionality which guarantee correct memory management.
@end(section)

@begin(section)
   @title(Idiosyncrasies)
   In Common Lisp setters usually return the value they set, e.g.
   @c((setf (foo-bar foo) x)) returns @c(x). In cl-libheif functions whose
   purpose is to set something do not return a value, i.e. have the return type
   @c((values &optional)).
@end(section)

@begin(section)
   @title(Examples)
   @b(NB:) On some platforms (OSes / Lisp implementations) it's necessary to
   mask floating point traps, otherwise the lisp would crash (I mean it). It can
   be done in a portable way with @c(float-features:with-float-traps-masked).
   @begin(section)
     @title(Image decoding)
     This function decodes an image (in color) from a file and returns an array
     with 3 color components per pixel:
     @begin[lang=lisp](code)
(serapeum:-> decode ((or pathname string))
             (values (simple-array (unsigned-byte 8) (* * 3)) &optional))
(defun decode (name)
  (with-libheif (+default-init-parameters+)
    (with-context (ctx)
      (context-read-from-file! ctx name)
      (with-primary-image-handle (handle ctx)
        (with-decode-image (image handle :rgb :interleaved-rgb +default-decoding-options+)
          (image-plane-data image :interleaved))))))
     @end(code)

     The same for a grayscale image:
     @begin[lang=lisp](code)
(serapeum:-> decode ((or pathname string))
             (values (simple-array (unsigned-byte 8) (* * 1)) &optional))
(defun decode (name)
  (with-libheif (+default-init-parameters+)
    (with-context (ctx)
      (context-read-from-file! ctx name)
      (with-primary-image-handle (handle ctx)
        (with-decode-image (image handle :monochrome :monochrome +default-decoding-options+)
          (image-plane-data image :y))))))
     @end(code)

     You can obtain a preferred colorspace with
     @c(image-handle-preferred-decoding-colorspace).
   @end(section)

   @begin(section)
     @title(Image encoding)
     Encode an image and write the result to a file.
     @begin[lang=lisp](code)
(serapeum:-> encode ((simple-array (unsigned-byte 8) (* * 3)) (or pathname string))
             (values &optional))
(defun encode (data name)
  (let ((height (array-dimension data 0))
        (width  (array-dimension data 1)))
    (with-libheif (+default-init-parameters+)
      (with-context (ctx)
        (with-image (image width height :rgb :interleaved-rgb)
          (image-add-plane! image :interleaved width height 24)
          (image-set-plane-data!  image :interleaved data)
          (with-encoder-for-format (encoder ctx :hevc)
            (encoder-set-lossy-quality! encoder 90)
            (context-encode-image! ctx image encoder
                                   +default-encoding-options+)
            (context-write-to-file! ctx name)))))))
     @end(code)
   @end(section)

   @begin(section)
     @title(Metadata)
     Read all metadata blocks in a list (each element is a simple array of
     octets):
     @begin[lang=lisp](code)
(serapeum:-> read-metadata ((or pathname string))
             (values list &optional))
(defun read-metadata (name)
  (with-libheif (+default-init-parameters+)
    (with-context (ctx)
      (context-read-from-file! ctx name)
      (with-primary-image-handle (handle ctx)
        (mapcar
         (lambda (ref)
           (image-handle-metadata handle ref))
         (image-handle-metadata-refs handle))))))
     @end(code)
   @end(section)
@end(section)

@begin(section)
   @title(API)
   @begin(section)
     @title(Conditions)
     @cl:with-package[name="cl-libheif"](
       @cl:doc(condition cl-libheif-error)
       @cl:doc(condition libheif-error)
       @cl:doc(condition bps-error)
       @cl:doc(condition no-plane-error)
       @cl:doc(condition dimensions-mismatch)
     )
   @end(section)

   @begin(section)
     @title(libheif (de)initialization)
     @cl:with-package[name="cl-libheif"](
       @cl:doc(variable +default-init-parameters+)
       @cl:doc(macro with-libheif)
     )
   @end(section)

   @begin(section)
     @title(Context)
     @cl:with-package[name="cl-libheif"](
       @cl:doc(macro with-context)
       @cl:doc(function context-read-from-file!)
       @cl:doc(function context-read-from-octets!)
       @cl:doc(function context-write-to-file!)
       @cl:doc(function context-write-to-octets)
       @cl:doc(function context-top-level-image-ids)
       @cl:doc(function context-primary-image-id)
       @cl:doc(function context-set-maximum-image-size-limit!)
       @cl:doc(function context-set-max-decoding-threads!)
     )
   @end(section)

   @begin(section)
     @title(Image handles)
     @cl:with-package[name="cl-libheif"](
       @cl:doc(macro with-primary-image-handle)
       @cl:doc(macro with-image-handle)
       @cl:doc(function image-handle-width)
       @cl:doc(function image-handle-height)
       @cl:doc(type colorspace)
       @cl:doc(type chroma)
       @cl:doc(function image-handle-preferred-decoding-colorspace)
     )
   @end(section)

   @begin(section)
     @title(Images)
     @cl:with-package[name="cl-libheif"](
       @cl:doc(type channel)
       @cl:doc(function image-width)
       @cl:doc(function image-height)
       @cl:doc(function image-bits-per-pixel)
       @cl:doc(function image-bits-per-pixel-range)
       @cl:doc(function image-plane-data)
       @cl:doc(macro with-image)
       @cl:doc(function image-add-plane!)
       @cl:doc(function image-set-plane-data!)
     )
   @end(section)

   @begin(section)
     @title(Encoding)
     @cl:with-package[name="cl-libheif"](
       @cl:doc(function encoder-descriptors)
       @cl:doc(function encoder-descriptor-name)
       @cl:doc(function encoder-descriptor-id-name)
       @cl:doc(function encoder-descriptor-compression-format)
       @cl:doc(function encoder-descriptor-supports-lossy-compression-p)
       @cl:doc(function encoder-descriptor-supports-lossless-compression-p)
       @cl:doc(variable +default-encoding-options+)
       @cl:doc(type compression-format)
       @cl:doc(macro with-encoder)
       @cl:doc(macro with-encoder-for-format)
       @cl:doc(function encoder-set-lossy-quality!)
       @cl:doc(function encoder-set-lossless!)
       @cl:doc(function context-encode-image!)
     )
   @end(section)

   @begin(section)
     @title(Decoding)
     @cl:with-package[name="cl-libheif"](
       @cl:doc(variable +default-decoding-options+)
       @cl:doc(macro with-decode-image)
     )
   @end(section)

   @begin(section)
     @title(Metadata)
     @cl:with-package[name="cl-libheif"](
       @cl:doc(defconstructor metadata-ref)
       @cl:doc(function image-handle-metadata-refs)
       @cl:doc(function image-handle-metadata)
     )
   @end(section)
@end(section)
